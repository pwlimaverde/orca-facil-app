# Overview
A aplicação **OrcaFacilApp** (Gerenciador Simples de Orçamentos) é uma aplicação Android Nativa moderna, desenvolvida inteiramente com **Jetpack Compose** e **Kotlin**. O objetivo é proporcionar imersão no desenvolvimento profissional Android, focando em arquitetura limpa, reatividade e UI declarativa.

O sistema resolve o problema de rastreamento de custos, permitindo que o usuário cadastre produtos, valores e quantidades para calcular e armazenar múltiplos orçamentos de forma persistente.

# Core Features
- **Gerenciamento de Múltiplos Orçamentos (RF1.0)**
  - Suportar a criação, visualização e armazenamento de vários registros `Budget`.
  - Persistência local robusta utilizando Room Database.

- **Cálculo de Custos Reativo (RF3.0, RF5.0)**
  - Cálculo do Subtotal por item ($Valor\ Unitário \times Quantidade$) em tempo real.
  - Cálculo e atualização automática do `valor_estimado_total` do Orçamento via observação de estado (StateFlow).

- **Visualização e Listagem (RF6.0, RF7.0)**
  - Tela inicial com lista de orçamentos (`LazyColumn`).
  - Tela de detalhes exibindo itens do orçamento e total acumulado.

# User Experience (UX) & UI Strategy
A interface será construída 100% em **Jetpack Compose**, seguindo os princípios do Material Design 3.
Navegação baseada em **Navigation Compose** (Single Activity).

- **Tela 1: Home (BudgetListScreen)**
  - Componente: `Scaffold` com `TopAppBar`.
  - Conteúdo: `LazyColumn` exibindo cards de orçamentos (`BudgetCard`).
  - Estado: Observa `BudgetListUiState` (Loading, Success, Error).
  - Ações: FAB (Floating Action Button) para criar Novo Orçamento (→ Rota: `add_budget`). Clique no card para ver detalhes (→ Rota: `budget_details/{budgetId}`).

- **Tela 2: Cadastro de Orçamento (AddBudgetScreen)**
  - Componente: Formulário com `OutlinedTextField`.
  - Estado: `AddBudgetUiState` para validação de campos em tempo real.
  - Ação: Botão "Salvar" persiste via ViewModel e navega de volta (`popBackStack`).

- **Tela 3: Detalhes do Orçamento (BudgetDetailScreen)**
  - Componente: Exibe cabeçalho com dados do orçamento e total.
  - Conteúdo: `LazyColumn` listando `BudgetItemCard`.
  - Lógica: O total deve ser um `Flow` derivado da soma dos itens no banco de dados.
  - Ação: Botão para Adicionar Novo Item (→ Rota: `add_item/{budgetId}`).

- **Tela 4: Cadastro de Novo Item (AddItemScreen)**
  - Componente: Formulário para `Nome`, `Valor` e `Quantidade`.
  - Lógica: Inputs numéricos com `KeyboardOptions(keyboardType = KeyboardType.Number)`.
  - Ação: Botão "Adicionar" insere o item e atualiza reativamente a Tela 3.

# Technical Architecture

## Stack Tecnológica
- **Plataforma**: Android Nativo (Min SDK: 24).
- **Linguagem**: Kotlin.
- **UI Toolkit**: **Jetpack Compose** (BOM 2024+).
  - Material 3.
  - Navigation Compose.
- **Arquitetura**: MVVM (Model-View-ViewModel).
- **Persistência**: Room Persistence Library (com suporte a Coroutines/Flow).
- **Injeção de Dependência**: Hilt (Recomendado) ou Manual DI (Koin/Container Simples) para simplicidade, mas estruturado para testabilidade.
- **Assincronismo**: Kotlin Coroutines & Flow.

## Modelagem de Dados (Room Entities)

**Entidade: Orçamento (`Budget`)**
- `id`: Long (PK, AutoGenerate)
- `nome`: String
- `descricao`: String
- `data_criacao`: Long (Timestamp)

**Entidade: Item de Orçamento (`BudgetItem`)**
- `id`: Long (PK, AutoGenerate)
- `budget_id`: Long (FK - Vínculo com Budget, OnDelete = CASCADE)
- `nome_produto`: String
- `valor_unitario`: Double
- `quantidade`: Int

**DTO/Relation:**
- `BudgetWithItems`: Data class contendo `@Embedded Budget` e `@Relation List<BudgetItem>` para cálculos de totais.

# Development Roadmap

- **Fase 1: Setup e Core (Infrastructure)**
  - Configuração do Gradle (Compose, Room, Navigation, Hilt/Koin).
  - Definição do `Theme.kt` (Cores, Tipografia, Shapes).
  - Implementação da Camada de Dados (Entities, DAOs, Database, Repository).

- **Fase 2: Fluxo de Orçamentos (Feature: Budget)**
  - Implementação do `BudgetViewModel`.
  - Criação da `AddBudgetScreen` (Formulário).
  - Criação da `BudgetListScreen` (Listagem).
  - Configuração do Navigation Graph inicial.

- **Fase 3: Fluxo de Itens e Detalhes (Feature: Items)**
  - Implementação do `BudgetItemViewModel`.
  - Criação da `BudgetDetailScreen` (Mestre-Detalhe).
  - Criação da `AddItemScreen`.
  - Lógica de atualização de totais em tempo real via `Flow`.

- **Fase 4: Refinamento e Testes**
  - Testes Unitários (ViewModels e Cálculos).
  - Testes de UI (Compose Test Rule).
  - Polimento de UI (Espaçamentos, Animações de navegação, Tratamento de erros).

# Logical Dependency Chain
1.  **Database**: DAOs precisam retornar `Flow<>` para a UI ser reativa.
2.  **Repository**: Deve abstrair a fonte de dados para os ViewModels.
3.  **Navigation**: Deve ser configurada na `MainActivity` antes das telas existirem, usando rotas tipadas ou Strings constantes.
4.  **State Hoisting**: As telas (Composables) não devem ter lógica de negócio; elas recebem estado e emitem eventos para o ViewModel.

# Risks and Mitigations
- **Complexidade do Compose State**: Gerenciar recomposições desnecessárias.
  - *Mitigação*: Usar `remember`, `derivedStateOf` e chaves estáveis.
- **Navegação com Argumentos**: Passar objetos complexos na navegação.
  - *Mitigação*: Passar apenas o ID (`budgetId`) e fazer o ViewModel de destino buscar os dados no Repository.

# Appendix
- **Nome do Projeto**: OrcaFacilApp
- **Package Name**: `com.pwlimaverde.orcafacilapp`
