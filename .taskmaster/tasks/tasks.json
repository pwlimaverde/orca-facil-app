{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Configuração Inicial e Dependências do Projeto",
        "description": "Configurar o build.gradle com as dependências necessárias para Jetpack Compose, Room, Navigation Compose e Injeção de Dependência (Hilt ou Koin).",
        "details": "Adicionar dependências: \n- Room (runtime, ktx, compiler)\n- Navigation Compose\n- Hilt (android, compiler, navigation-compose)\n- ViewModel Compose\n- Coroutines.\nConfigurar Java 17/Kotlin options. Sincronizar o projeto e garantir build limpo.",
        "testStrategy": "Executar './gradlew build' para garantir que todas as dependências foram resolvidas sem conflitos.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuração de Versões do Java e Kotlin no Gradle",
            "description": "Configurar o projeto para utilizar Java 17 e definir as opções do compilador Kotlin nos arquivos build.gradle.",
            "dependencies": [],
            "details": "No 'build.gradle' (app), definir 'compileOptions' e 'kotlinOptions' para 'JavaVersion.VERSION_17' e 'jvmTarget = \"17\"'. Atualizar versões dos plugins do Kotlin e Android Gradle Plugin no 'build.gradle' (project) para versões compatíveis.",
            "status": "pending",
            "testStrategy": "Sincronizar o Gradle (Sync Project with Gradle Files) e verificar se não ocorrem erros de compatibilidade de versão.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Adição das Dependências do Jetpack Compose e Material 3",
            "description": "Incluir as bibliotecas essenciais para a interface de usuário utilizando o BOM do Compose.",
            "dependencies": [
              1
            ],
            "details": "Adicionar 'androidx.compose:compose-bom' (ex: 2023.08.00 ou superior). Implementar dependências: 'ui', 'ui-graphics', 'ui-tooling-preview', 'material3'. Adicionar 'ui-tooling' e 'ui-test-manifest' como 'debugImplementation'.",
            "status": "pending",
            "testStrategy": "Executar um build limpo e verificar se as classes do Compose (ex: @Composable) são resolvidas no editor.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementação das Dependências do Room Database",
            "description": "Adicionar as bibliotecas do Room para persistência de dados local, incluindo runtime, KTX e compilador.",
            "dependencies": [
              1
            ],
            "details": "Aplicar o plugin 'kotlin-kapt' ou 'com.google.devtools.ksp' no topo do 'build.gradle'. Adicionar 'androidx.room:room-runtime', 'androidx.room:room-ktx' e 'androidx.room:room-compiler' (kapt/ksp).",
            "status": "pending",
            "testStrategy": "Criar uma classe dummy anotada com @Entity e tentar compilar para verificar se o processador de anotações do Room está ativo.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configuração do Hilt para Injeção de Dependência",
            "description": "Integrar o Dagger Hilt ao projeto, configurando plugins e dependências necessárias.",
            "dependencies": [
              1
            ],
            "details": "No 'build.gradle' (project), adicionar o classpath do Hilt. No app, aplicar plugin 'dagger.hilt.android.plugin'. Adicionar dependências 'com.google.dagger:hilt-android' e 'hilt-compiler'.",
            "status": "pending",
            "testStrategy": "Adicionar a anotação @HiltAndroidApp na classe Application (criar se não existir) e fazer o build para validar a geração de código do Hilt.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Adição de Navigation Compose e Componentes de Arquitetura",
            "description": "Incluir bibliotecas para navegação entre telas e gerenciamento de ciclo de vida com ViewModels.",
            "dependencies": [
              2,
              4
            ],
            "details": "Adicionar 'androidx.navigation:navigation-compose' para gestão de rotas. Adicionar 'androidx.hilt:hilt-navigation-compose' para integração com DI. Incluir 'androidx.lifecycle:lifecycle-viewmodel-compose' e 'kotlinx-coroutines-android'.",
            "status": "pending",
            "testStrategy": "Executar './gradlew dependencies' e verificar se não há conflitos de versão entre as bibliotecas de navegação e lifecycle.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-29T16:03:55.654Z"
      },
      {
        "id": 2,
        "title": "Implementação do Design System e Tema",
        "description": "Definir o tema base da aplicação utilizando Material Design 3, incluindo cores, tipografia e formas.",
        "details": "Criar/Atualizar 'Theme.kt', 'Color.kt', 'Type.kt'. Definir paleta de cores (Light/Dark) compatível com Material 3. Criar componentes base se necessário (ex: Espaçamentos padrão).",
        "testStrategy": "Verificar a renderização do @Preview do tema no Android Studio e garantir suporte a Dark Mode.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Definição da Paleta de Cores Material 3",
            "description": "Definir as constantes de cor e esquemas para os modos claro e escuro no arquivo Color.kt.",
            "dependencies": [],
            "details": "Criar ou atualizar o arquivo `ui/theme/Color.kt`. Declarar as variáveis de cor (hex codes) e criar instâncias de `ColorScheme` (lightColorScheme e darkColorScheme) mapeando cores primárias, secundárias, terciárias e de superfície conforme diretrizes do Material 3.",
            "status": "done",
            "testStrategy": "Compilar o projeto e garantir que as constantes de cor estão acessíveis via código."
          },
          {
            "id": 2,
            "title": "Configuração da Tipografia Padrão",
            "description": "Configurar os estilos de texto globais da aplicação no arquivo Type.kt utilizando a escala Material.",
            "dependencies": [],
            "details": "Criar ou atualizar o arquivo `ui/theme/Type.kt`. Instanciar o objeto `Typography` do Material 3 e definir os parâmetros (fontFamily, fontWeight, fontSize, lineHeight) para estilos como Display, Headline, Title, Body e Label.",
            "status": "done",
            "testStrategy": "Verificar a compilação do objeto Typography e sua disponibilidade para uso no tema."
          },
          {
            "id": 3,
            "title": "Implementação do Tema e Dynamic Color",
            "description": "Unificar cores e tipografia no composable do tema principal, com suporte a cores dinâmicas.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implementar o composable `OrcaFacilTheme` em `ui/theme/Theme.kt`. Adicionar lógica para verificar a versão do Android (S+) e aplicar `dynamicLightColorScheme`/`dynamicDarkColorScheme` se disponível. Configurar o `MaterialTheme` passando as cores e tipografia definidas anteriormente.",
            "status": "done",
            "testStrategy": "Criar um @Preview no Android Studio exibindo um componente de teste para validar visualmente a troca de temas (Light/Dark) e aplicação das fontes."
          }
        ],
        "updatedAt": "2025-11-29T16:45:00.000Z"
      },
      {
        "id": 3,
        "title": "Modelagem de Dados (Entidades Room)",
        "description": "Criar as classes de entidade para 'Budget' (Orçamento) e 'BudgetItem' (Item de Orçamento) com anotações do Room.",
        "details": "Criar data classes:\n1. `Budget`: id (PK, AutoGen), nome, descricao, data_criacao.\n2. `BudgetItem`: id (PK, AutoGen), budget_id (FK, onDelete=CASCADE), nome_produto, valor_unitario, quantidade.\n3. `BudgetWithItems`: Relation 1-N.",
        "testStrategy": "Verificar compilação das entidades e se as chaves estrangeiras estão corretamente anotadas.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementar Entidade Budget",
            "description": "Criar a data class 'Budget' anotada como entidade do Room para representar a tabela principal de orçamentos.",
            "dependencies": [],
            "details": "Criar arquivo `Budget.kt` no pacote de dados local. Anotar a classe com `@Entity(tableName = \"budgets\")`. Definir as propriedades: `id` (Int, @PrimaryKey(autoGenerate = true)), `nome` (String), `descricao` (String) e `dataCriacao` (Long).",
            "status": "done",
            "testStrategy": "Verificar se a classe compila e se as anotações do Room (Entity, PrimaryKey) estão presentes via reflexão ou teste unitário simples.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementar Entidade BudgetItem com Foreign Key",
            "description": "Criar a data class 'BudgetItem' representando os itens do orçamento, configurando a chave estrangeira e comportamento de cascata.",
            "dependencies": [
              1
            ],
            "details": "Criar arquivo `BudgetItem.kt`. Anotar com `@Entity(tableName = \"budget_items\", foreignKeys = [...])`. Definir FK vinculando `budget_id` ao `id` da entidade `Budget`, configurando `onDelete = ForeignKey.CASCADE`. Incluir colunas: id, nomeProduto, valorUnitario, quantidade. Adicionar índice na coluna `budget_id`.",
            "status": "done",
            "testStrategy": "Verificar a definição da Foreign Key e se o índice para a coluna da chave estrangeira foi definido para evitar warnings de compilação.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Criar Classe de Relação BudgetWithItems",
            "description": "Implementar a classe POJO para modelar a relação um-para-muitos entre Budget e BudgetItem.",
            "dependencies": [
              1,
              2
            ],
            "details": "Criar arquivo `BudgetWithItems.kt`. Definir data class contendo: `val budget: Budget` (anotado com `@Embedded`) e `val items: List<BudgetItem>` (anotado com `@Relation(parentColumn = \"id\", entityColumn = \"budget_id\")`).",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Camada de Dados: DAOs e Database",
        "description": "Implementar as interfaces DAO e a classe abstrata do Room Database.",
        "details": "1. `BudgetDao`: insert(), getAll() -> Flow<List<Budget>>, getById().\n2. `BudgetItemDao`: insert(), getItemsByBudget() -> Flow<List<BudgetItem>>, delete().\n3. `AppDatabase`: @Database(entities = [...], version = 1).",
        "testStrategy": "Criar testes instrumentados (AndroidTest) para validar inserção e leitura no banco em memória (inMemoryDatabaseBuilder).",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
            {
            "id": 1,
            "title": "Implementar BudgetDao",
            "description": "Criar a interface DAO para a entidade Budget com operações CRUD e consultas reativas.",
            "dependencies": [],
            "details": "Definir métodos: insertBudget (suspend), updateBudget (suspend), deleteBudget (suspend), getAllBudgets (Flow), getBudgetById (Flow), getBudgetWithItems (Flow + @Transaction).",
            "status": "done",
            "testStrategy": "Verificar a geração da classe _Impl pelo KSP.",
            "parentId": "4"
            },
            {
            "id": 2,
            "title": "Implementar BudgetItemDao",
            "description": "Criar a interface DAO para a entidade BudgetItem.",
            "dependencies": [],
            "details": "Definir métodos: insertItem (suspend), updateItem (suspend), deleteItem (suspend), getItemsByBudget (Flow).",
            "status": "done",
            "testStrategy": "Verificar a geração da classe _Impl pelo KSP.",
            "parentId": "4"
            },
            {
            "id": 3,
            "title": "Configurar AppDatabase e Módulo DI",
            "description": "Implementar a classe abstrata do Room e configurar a injeção de dependência com Hilt.",
            "dependencies": [
              1,
              2
            ],
            "details": "Criar `AppDatabase` estendendo `RoomDatabase`. Criar `DatabaseModule` no pacote `di` anotado com `@Module` e `@InstallIn(SingletonComponent)`. Prover `AppDatabase` (Singleton) e os DAOs.",
            "status": "done",
            "testStrategy": "Compilar o projeto e verificar se o grafo de dependências do Hilt é gerado corretamente.",
            "parentId": "4"
            }
        ]
      },
      {
        "id": 5,
        "title": "Camada de Repositório",
        "description": "Criar a camada de repositório para abstrair o acesso aos dados e fornecer uma API limpa para os ViewModels.",
        "details": "Criar interface `OrcaRepository` e implementação `OrcaRepositoryImpl`. Injetar DAOs via construtor. Expor funções suspensas para escrita e Flows para leitura.",
        "testStrategy": "Testes unitários mockando os DAOs para garantir que o repositório chama os métodos corretos.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definição da Interface OrcaRepository",
            "description": "Criar a interface pública que define o contrato de acesso aos dados para orçamentos e itens, garantindo o desacoplamento.",
            "dependencies": [],
            "details": "Criar o arquivo `OrcaRepository.kt` no pacote `com.example.orcafacilapp.data.repository`. Definir assinaturas para operações de leitura reativas (`Flow`) e escrita (`suspend`): `getBudgets(): Flow<List<Budget>>`, `getBudgetById(id: Long): Flow<Budget>`, `insertBudget(budget: Budget): Long`, `getItemsByBudget(budgetId: Long): Flow<List<BudgetItem>>`, `insertItem(item: BudgetItem)` e `deleteItem(item: BudgetItem)`.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementação da Classe OrcaRepositoryImpl",
            "description": "Implementar a lógica concreta do repositório delegando as chamadas para os DAOs injetados.",
            "dependencies": [
              1
            ],
            "details": "Criar a classe `OrcaRepositoryImpl` que implementa `OrcaRepository`. Injetar `BudgetDao` e `BudgetItemDao` via construtor (preparando para Hilt/Koin). Implementar os métodos da interface repassando as chamadas para os DAOs correspondentes. Exemplo: `override fun getBudgets() = budgetDao.getAll()`. Garantir o tratamento correto de corrotinas.",
            "status": "pending",
            "testStrategy": "Verificar a compilação e a correta injeção de dependências manuais ou automáticas.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Testes Unitários do Repositório",
            "description": "Validar a interação do repositório com os DAOs através de testes unitários isolados.",
            "dependencies": [
              2
            ],
            "details": "Configurar a classe de teste `OrcaRepositoryTest` no diretório `test`. Utilizar MockK para simular `BudgetDao` e `BudgetItemDao`. Implementar testes verificando: 1. Se `getAllBudgets` propaga o Flow retornado pelo DAO; 2. Se `insertBudget` invoca o DAO corretamente e retorna o ID; 3. Se `getItemsByBudget` filtra os itens corretamente via DAO.",
            "status": "pending",
            "testStrategy": "Executar testes unitários com JUnit e validar se todas as chamadas aos mocks ocorrem como esperado (verify).",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Configuração de Injeção de Dependência (DI)",
        "description": "Configurar os módulos de DI (Hilt/Koin) para prover Database, DAOs e Repository.",
        "details": "Se Hilt: Criar `AppModule` com @Provides @Singleton para Database e Repository. Anotar `Application` com @HiltAndroidApp e `MainActivity` com @AndroidEntryPoint.",
        "testStrategy": "Executar o app vazio para garantir que não há erros de runtime na inicialização do grafo de dependências.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "ViewModel: Gestão de Orçamentos",
        "description": "Implementar `BudgetViewModel` para gerenciar a lista de orçamentos e criação de novos.",
        "details": "Criar `BudgetViewModel`. Expor `uiState` (Loading, Success<List<Budget>>, Error). Funções: `saveBudget(nome, descricao)` e `getBudgets()`.",
        "testStrategy": "Testes unitários com Turbine para validar a emissão de estados do Flow.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "UI: Tela de Cadastro de Orçamento (AddBudgetScreen)",
        "description": "Criar a tela de formulário para adicionar um novo orçamento.",
        "details": "Composable `AddBudgetScreen`. Usar `OutlinedTextField` para Nome e Descrição. Botão 'Salvar' chama ViewModel. Tratar validação básica (campos não vazios).",
        "testStrategy": "Usar ComposeTestRule para verificar se o botão habilita apenas com campos preenchidos e se o callback de salvar é acionado.",
        "priority": "medium",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "UI: Tela de Listagem de Orçamentos (BudgetListScreen)",
        "description": "Criar a tela inicial que lista todos os orçamentos cadastrados.",
        "details": "Composable `BudgetListScreen`. Usar `Scaffold`, `TopAppBar` e `LazyColumn`. Criar componente `BudgetCard` para cada item. Adicionar FAB para navegar para `AddBudgetScreen`.",
        "testStrategy": "Verificar se a lista exibe os itens mockados e se o clique no FAB dispara o evento de navegação.",
        "priority": "medium",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Configuração de Navegação (Navigation Graph)",
        "description": "Configurar o NavHost e as rotas da aplicação para o fluxo de orçamentos.",
        "details": "Definir rotas: 'home', 'add_budget'. Configurar `NavHost` na `MainActivity`. Conectar `BudgetListScreen` e `AddBudgetScreen`.",
        "testStrategy": "Navegação manual: Abrir App -> Clicar FAB -> Preencher -> Salvar -> Verificar retorno para Home.",
        "priority": "high",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Definição da Estrutura de Rotas (Sealed Classes)",
            "description": "Criar uma estrutura de rotas segura utilizando Sealed Class para mapear os destinos da navegação.",
            "dependencies": [],
            "details": "Criar arquivo `ui/navigation/Screen.kt` (ou `Routes.kt`). Definir `sealed class Screen(val route: String)`. Implementar os objetos `object Home : Screen(\"home\")` e `object AddBudget : Screen(\"add_budget\")`. Isso facilitará a manutenção das strings de rota.",
            "status": "pending",
            "testStrategy": "Verificar se as strings de rota são acessíveis estaticamente em um teste unitário simples.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementação do NavHost e Configuração do Grafo",
            "description": "Implementar o componente NavHost que gerencia a troca de telas entre a listagem e o formulário.",
            "dependencies": [
              1
            ],
            "details": "Criar um Composable (ex: `AppNavGraph`) que recebe um `NavHostController`. Configurar `NavHost` com `startDestination = Screen.Home.route`. Adicionar `composable(Screen.Home.route)` instanciando `BudgetListScreen` (passando callback para navegar para AddBudget) e `composable(Screen.AddBudget.route)` instanciando `AddBudgetScreen` (passando callback para `popBackStack`).",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integração do NavController na MainActivity",
            "description": "Configurar a MainActivity para hospedar o sistema de navegação dentro do tema da aplicação.",
            "dependencies": [
              2
            ],
            "details": "Na `MainActivity.kt`, dentro de `setContent` e do bloco do tema: 1. Instanciar `val navController = rememberNavController()`. 2. Chamar o Composable `AppNavGraph` (ou onde o NavHost foi definido) passando o `navController`. Garantir que a Activity esteja anotada com `@AndroidEntryPoint`.",
            "status": "pending",
            "testStrategy": "Executar o app no emulador e verificar se a tela inicial (Home) é carregada sem crashes.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 11,
        "title": "ViewModel: Itens do Orçamento",
        "description": "Implementar `BudgetItemViewModel` para gerenciar detalhes e itens de um orçamento específico.",
        "details": "Receber `budgetId` via SavedStateHandle. Expor `uiState` com dados do orçamento, lista de itens e `totalEstimado`. Lógica reativa: `total = itens.sumOf { it.valor * it.qtd }`.",
        "testStrategy": "Testes unitários validando o cálculo do total ao adicionar/remover itens.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "UI: Tela de Cadastro de Item (AddItemScreen)",
        "description": "Criar tela para adicionar produtos/itens a um orçamento.",
        "details": "Composable `AddItemScreen`. Campos: Nome (Texto), Valor (Decimal), Quantidade (Inteiro). Configurar `KeyboardOptions` numérico. Validar inputs.",
        "testStrategy": "Verificar input types corretos (teclado numérico abre para valor e quantidade).",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "UI: Tela de Detalhes do Orçamento (BudgetDetailScreen)",
        "description": "Criar tela Mestre-Detalhe exibindo cabeçalho, lista de itens e total calculado.",
        "details": "Composable `BudgetDetailScreen`. Header com info do Budget. `LazyColumn` para `BudgetItemCard`. Footer ou Header fixo com Total Calculado reativo. Botão para `AddItemScreen`.",
        "testStrategy": "Verificar se o Total atualiza automaticamente na UI ao adicionar um item e voltar para esta tela.",
        "priority": "high",
        "dependencies": [
          "11",
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Integração de Navegação Completa",
        "description": "Atualizar o Navigation Graph para suportar argumentos e fluxo de itens.",
        "details": "Adicionar rotas: 'budget_detail/{budgetId}' e 'add_item/{budgetId}'. Garantir passagem correta de argumentos (Long) entre as telas.",
        "testStrategy": "Teste de fluxo completo: Home -> Detalhe (ID correto) -> Add Item -> Salvar -> Detalhe (Verificar Item presente).",
        "priority": "high",
        "dependencies": [
          "10",
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Refinamento de UI e Testes Finais",
        "description": "Polimento visual, tratamento de erros de banco de dados e testes de instrumentação finais.",
        "details": "Melhorar layout dos Cards. Adicionar estados de 'Empty View' (listas vazias). Tratar exceções de IO com CoroutineExceptionHandler. Executar testes finais.",
        "testStrategy": "Executar bateria completa de testes unitários e instrumentados. Verificação visual de espaçamentos e alinhamentos.",
        "priority": "low",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Coleta de Evidências (Screenshots e Códigos)",
        "description": "Coletar e organizar as evidências visuais e de código necessárias para o Paper, conforme exigido nas diretrizes.",
        "details": "Capturar screenshots de alta qualidade das 4 telas principais: Home, Cadastro de Orçamento, Detalhes e Cadastro de Item. Selecionar trechos de código significativos: Lógica de Cálculo (ViewModel/UseCase) e Persistência (DAO/Room). Salvar em pasta 'doc/evidencias'.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "15"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Preparação de Diretórios e Captura de Screenshots das Telas Principais",
            "description": "Criar a estrutura de pastas destinada à documentação do projeto e realizar a captura das telas fundamentais do aplicativo para compor as evidências visuais do Paper.",
            "dependencies": [],
            "details": "Criar o diretório 'doc/evidencias' na raiz do projeto. Executar a aplicação e capturar screenshots em alta resolução (PNG) das seguintes telas: 1. Home (Lista de Orçamentos), 2. Cadastro de Orçamento, 3. Detalhes do Orçamento e 4. Cadastro de Item. Renomear os arquivos de forma semântica (ex: 'tela_home.png', 'tela_cadastro.png').",
            "status": "pending",
            "testStrategy": "Verificar se a pasta 'doc/evidencias' existe e contém 4 arquivos de imagem válidos correspondentes às telas solicitadas.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Extração de Trechos de Código de Lógica de Negócio e Cálculos",
            "description": "Identificar e extrair a lógica responsável pelos cálculos financeiros do aplicativo, demonstrando o uso de StateFlow ou LiveData e regras de negócio no ViewModel.",
            "dependencies": [
              1
            ],
            "details": "Navegar até o diretório dos ViewModels (ex: 'ui/viewmodel'). Localizar a função responsável pelo cálculo do valor total do orçamento (soma dos itens x quantidade). Copiar o trecho de código relevante, mantendo as assinaturas e lógica principal, e salvar em um arquivo de texto ou markdown em 'doc/evidencias/snippet_logica_calculo.kt'.",
            "status": "pending",
            "testStrategy": "Confirmar a criação do arquivo 'snippet_logica_calculo.kt' contendo a lógica de soma/atualização de valores do orçamento.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extração de Trechos de Código da Camada de Persistência (Room)",
            "description": "Coletar evidências da implementação do banco de dados local, focando nas interfaces DAO e nas anotações da biblioteca Room.",
            "dependencies": [
              2
            ],
            "details": "Navegar até o diretório de dados/DAO (ex: 'data/dao'). Selecionar a interface principal (ex: 'OrcamentoDao.kt'). Copiar os métodos anotados com @Insert, @Query (especialmente consultas com JOIN ou filtros) e @Transaction. Salvar este conteúdo em 'doc/evidencias/snippet_persistencia_room.kt' para uso na fundamentação teórica.",
            "status": "pending",
            "testStrategy": "Verificar se o arquivo 'snippet_persistencia_room.kt' foi criado e contém as anotações do Room corretamente formatadas.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 17,
        "title": "Escrita do Corpo do Paper (Fundamentação e Metodologia)",
        "description": "Escrever a Fundamentação Teórica e Metodologia do Paper, garantindo o cumprimento dos requisitos de conteúdo (10+ parágrafos), citações e inserção correta de evidências de código e tela.",
        "status": "pending",
        "dependencies": [
          "16"
        ],
        "priority": "high",
        "details": "Obrigatório: 1. Escrever no mínimo 10 parágrafos para a Fundamentação Teórica. 2. Inserir evidências de CÓDIGO (snippets) diretamente na Fundamentação Teórica para ilustrar conceitos (conforme item 94 das diretrizes). 3. Inserir evidências de TELAS (screenshots) na Metodologia ou na Fundamentação, dependendo de onde fizer mais sentido contextual. Citar livros/artigos sobre Kotlin, Android Jetpack e Room.",
        "testStrategy": "Revisão de conformidade com a ABNT e checklist de diretrizes (item 94).",
        "subtasks": [
          {
            "id": 1,
            "title": "Redação da Fundamentação Teórica com Snippets de Código",
            "description": "Elaborar o texto da Fundamentação Teórica (mínimo 10 parágrafos) integrando conceitos e evidências de código.",
            "dependencies": [],
            "details": "Escrever sobre Kotlin (segurança, concisão), Android Jetpack Compose e Room. IMPORTANTE: Inserir snippets de código do projeto (ex: definições de Entidades em 'Budget.kt', interfaces 'DAO' ou temas em 'Theme.kt') diretamente nesta seção para fundamentar a teoria, conforme diretriz 94. Obrigatório incluir citações bibliográficas.",
            "status": "pending",
            "testStrategy": "Verificar contagem de parágrafos (>=10) e presença de blocos de código formatados corretamente no meio do texto teórico.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Escrita da Metodologia e Ferramentas",
            "description": "Descrever a metodologia de desenvolvimento, ambiente, configurações de build e fluxo de trabalho.",
            "dependencies": [
              1
            ],
            "details": "Documentar o uso do Android Studio, Kotlin DSL (build.gradle.kts) e API Level 28. Explicar o fluxo: Banco de Dados (Room) -> Lógica (Repository/ViewModel) -> UI (Compose). Preparar o texto para receber as capturas de tela.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Inserção de Evidências Visuais (Telas) e Legendas",
            "description": "Integrar as capturas de tela (evidências de funcionamento) ao texto da Metodologia ou Fundamentação.",
            "dependencies": [
              2
            ],
            "details": "Inserir as imagens das telas (Home, Detalhes, Formulários) prioritariamente na Metodologia, ou na Fundamentação se estiver explicando um componente visual específico. Adicionar legendas explicativas numeradas (ex: 'Figura 1: Tela Principal') e referenciar no texto.",
            "status": "pending",
            "testStrategy": "Inspeção visual: Confirmar que códigos estão na Fundamentação e Telas estão contextualizadas com legendas.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 18,
        "title": "Finalização e Formatação do Paper ABNT",
        "description": "Finalizar o Paper com Introdução, Resumo e Considerações Finais, seguindo a ordem lógica de escrita.",
        "details": "Escrever a Introdução (contextualização e objetivos). Escrever as Considerações Finais (conclusões e aprendizados). Por último, escrever o Resumo (max 250 palavras, parágrafo único). Formatar todo o documento nas normas da ABNT.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "17"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Redação da Introdução e Considerações Finais",
            "description": "Escrever as seções de abertura e fechamento do Paper acadêmico, contextualizando o projeto OrcaFacilApp.",
            "dependencies": [],
            "details": "Elaborar a Introdução definindo o problema de gestão de orçamentos e os objetivos do aplicativo. Redigir as Considerações Finais destacando o aprendizado com Kotlin e Room, as dificuldades superadas e as conclusões sobre a solução desenvolvida.",
            "status": "pending",
            "testStrategy": "Revisão textual para garantir coesão com a Fundamentação Teórica e Metodologia.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Elaboração do Resumo (Abstract)",
            "description": "Produzir o resumo técnico do trabalho conforme as limitações de palavras e estrutura normativa.",
            "dependencies": [
              1
            ],
            "details": "Escrever o Resumo em parágrafo único (max 250 palavras), abordando o contexto, objetivo, método (desenvolvimento Android) e resultados. Definir 3 a 5 palavras-chave (ex: Desenvolvimento Mobile, Kotlin, Gestão).",
            "status": "pending",
            "testStrategy": "Verificação de contagem de palavras e presença dos elementos essenciais (contexto, objetivo, método, resultado).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Formatação ABNT e Revisão Geral",
            "description": "Aplicar as normas da ABNT em todo o documento e realizar a revisão final antes da entrega.",
            "dependencies": [
              2
            ],
            "details": "Ajustar margens, fontes (Arial/Times 12), espaçamento (1.5) e numeração. Verificar citações (autor-data) e referências bibliográficas. Garantir que as figuras (evidências do app) tenham títulos e fontes corretas.",
            "status": "pending",
            "testStrategy": "Validação visual contra o template institucional e checklist de normas da ABNT.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 19,
        "title": "Elaboração do PPT de Socialização",
        "description": "Elaborar a apresentação em PPT para a Socialização do projeto.",
        "details": "Criar slides contendo: Capa, Introdução, Objetivos, Tecnologias Utilizadas, Evidências (Telas e Código) e Conclusão. Garantir clareza e objetividade para a apresentação oral.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "18"
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-29T16:30:06.992Z",
      "taskCount": 19,
      "completedCount": 1,
      "tags": [
        "master"
      ],
      "created": "2025-11-29T16:30:29.216Z",
      "description": "Tasks for master context"
    }
  }
}